// +build pantry

package pantry

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"
	"testing"
	"text/template"
	"time"
)

type generator struct {
	Time time.Time
	Name string
}

const generateTemplate = `// Package pantry - Generated by go generate generate.go
// Created on {{ .Time }}
package pantry

import (
	"fmt"

	"github.com/hashicorp/hcl2/hcl"
	"github.com/hashicorp/hcl2/hcldec"
	"github.com/mikemackintosh/bakery/cli"
	"github.com/zclconf/go-cty/cty"
)

// {{.Name | exported}} is a {{.Name}} object
type {{.Name | exported}} struct {
	PantryItem
	Name           string   ` + "`hcl:\"name,label\"`\n" +
	`		Config         hcl.Body ` + "`hcl:\",remain\"`\n" +
	`		Source         string ` + "`json:\"source\"`\n" +
	`	}

// Identifies the {{.Name}} spec
var {{.Name | lower}}Spec = NewPantrySpec(&hcldec.ObjectSpec{
	"source": &hcldec.AttrSpec{
		Name:     "source",
		Required: true,
		Type:     cty.String,
	},
})


// Parse the confgiuration with the provided spec
func (p *{{.Name | exported}}) Parse(evalContext *hcl.EvalContext) error {
	cli.Debug(cli.INFO, "Preparing {{.Name }}", p.Name)
	cfg, diags := hcldec.Decode(p.Config, {{.Name | lower}}Spec, evalContext)
	if len(diags) != 0 {
		for _, diag := range diags {
			cli.Debug(cli.INFO, "\t#", diag)
		}
		return fmt.Errorf("%s", diags.Errs()[0])
	}

	err := p.Populate(cfg, p)
	if err != nil {
		return err
	}

	return nil
}

// Bake will action the configuration
func (p *{{.Name | exported}}) Bake() {
	//
}
`

var moduleName string

func init() {
	flag.StringVar(&moduleName, "name", "", "module name; must be set")
}

func TestGenerate(test *testing.T) {
	flag.Parse()

	if len(moduleName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	var buf bytes.Buffer
	var funcMap = template.FuncMap{
		"title": strings.Title,
		"lower": func(s string) string {
			return strings.ToLower(string(s))
		},
		"exported": func(s string) string {
			return strings.Title(string(s[0])) + string(s[1:])
		},
	}

	t := template.Must(template.New("").Funcs(funcMap).Parse(generateTemplate))

	data := generator{
		Time: time.Now(),
		Name: strings.ToLower(moduleName),
	}

	err := t.Execute(&buf, data)
	if err != nil {
		panic(err)
	}

	err = ioutil.WriteFile(fmt.Sprintf("%s.go", strings.ToLower(moduleName)), buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}
